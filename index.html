<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IQ 17 - Fixed & Online</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #fff; font-family: sans-serif; text-align: center; overflow: hidden; }
        canvas { border-bottom: 2px solid #eee; display: block; margin: 0 auto; touch-action: none; background: #fafafa; }
        #ui { padding: 10px; background: #fff; height: 140px; box-shadow: 0 -2px 10px rgba(0,0,0,0.05); }
        .btn { padding: 10px 20px; background: #0070FF; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 5px; font-weight: bold; }
        #peer-id-display { font-size: 11px; color: #888; margin-top: 8px; }
        #status { font-size: 18px; font-weight: bold; color: #333; margin-bottom: 5px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div id="status">Waiting for Connection...</div>
        <div>
            <button class="btn" onclick="copyMyID()">Copy ID</button>
            <button class="btn" onclick="connectToPeer()">Join Friend</button>
        </div>
        <div id="peer-id-display">My ID: Loading...</div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusDiv = document.getElementById('status');
const idDisplay = document.getElementById('peer-id-display');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 160;

// --- MULTIPLAYER SETUP ---
let peer = new Peer(); 
let conn = null;
let myRole = null; 

peer.on('open', (id) => {
    idDisplay.innerText = "My ID: " + id;
    statusDiv.innerText = "Host a Game or Join";
});

peer.on('connection', (c) => {
    conn = c; myRole = 'blue';
    setupConnection();
    statusDiv.innerText = "Friend joined! Blue's Turn";
});

function connectToPeer() {
    let peerId = prompt("Enter Friend's ID:");
    if (peerId) {
        conn = peer.connect(peerId);
        myRole = 'red';
        setupConnection();
        statusDiv.innerText = "Connected! Waiting for Blue";
    }
}

function setupConnection() {
    conn.on('data', (data) => {
        gameState = data;
        drawBoard();
        updateStatus();
    });
}

function sendMove() {
    if (conn && conn.open) conn.send(gameState);
}

function copyMyID() {
    const idText = idDisplay.innerText.replace("My ID: ", "");
    navigator.clipboard.writeText(idText);
    alert("ID Copied! Send it to your friend.");
}

// --- GAME DATA ---
const scaleX = canvas.width / 400;
const scaleY = canvas.height / 700;

const nodes = {
    0: {x: 200*scaleX, y: 50*scaleY}, 1: {x: 80*scaleX, y: 110*scaleY}, 2: {x: 160*scaleX, y: 110*scaleY}, 3: {x: 240*scaleX, y: 110*scaleY}, 4: {x: 320*scaleX, y: 110*scaleY},
    5: {x: 80*scaleX, y: 180*scaleY}, 6: {x: 160*scaleX, y: 180*scaleY}, 7: {x: 240*scaleX, y: 180*scaleY}, 8: {x: 320*scaleX, y: 180*scaleY},
    9: {x: 80*scaleX, y: 250*scaleY}, 10: {x: 160*scaleX, y: 250*scaleY}, 11: {x: 240*scaleX, y: 250*scaleY}, 12: {x: 320*scaleX, y: 250*scaleY},
    13: {x: 50*scaleX, y: 320*scaleY}, 14: {x: 110*scaleX, y: 320*scaleY}, 15: {x: 170*scaleX, y: 320*scaleY}, 16: {x: 230*scaleX, y: 320*scaleY}, 17: {x: 290*scaleX, y: 320*scaleY}, 18: {x: 350*scaleX, y: 320*scaleY},
    19: {x: 50*scaleX, y: 370*scaleY}, 20: {x: 110*scaleX, y: 370*scaleY}, 21: {x: 170*scaleX, y: 370*scaleY}, 22: {x: 230*scaleX, y: 370*scaleY}, 23: {x: 290*scaleX, y: 370*scaleY}, 24: {x: 350*scaleX, y: 370*scaleY},
    30: {x: 50*scaleX, y: 420*scaleY}, 29: {x: 110*scaleX, y: 420*scaleY}, 28: {x: 170*scaleX, y: 420*scaleY}, 27: {x: 230*scaleX, y: 420*scaleY}, 26: {x: 290*scaleX, y: 420*scaleY}, 25: {x: 350*scaleX, y: 420*scaleY},
    31: {x: 80*scaleX, y: 490*scaleY}, 32: {x: 160*scaleX, y: 490*scaleY}, 33: {x: 240*scaleX, y: 490*scaleY}, 34: {x: 320*scaleX, y: 490*scaleY},
    38: {x: 80*scaleX, y: 560*scaleY}, 37: {x: 160*scaleX, y: 560*scaleY}, 36: {x: 240*scaleX, y: 560*scaleY}, 35: {x: 320*scaleX, y: 560*scaleY},
    39: {x: 80*scaleX, y: 630*scaleY}, 40: {x: 160*scaleX, y: 630*scaleY}, 41: {x: 240*scaleX, y: 630*scaleY}, 42: {x: 320*scaleX, y: 630*scaleY},
    43: {x: 200*scaleX, y: 680*scaleY}
};

const roads = [[0,2],[0,3],[1,2],[2,3],[3,4],[1,5],[2,6],[3,7],[4,8],[5,6],[6,7],[7,8],[5,9],[6,10],[7,11],[8,12],[9,10],[10,11],[11,12],[2,5],[3,6],[6,9],[4,7],[7,10],[8,11],[9,13],[9,14],[10,14],[10,15],[11,16],[11,17],[12,18],[12,17],[13,14],[14,15],[16,17],[17,18],[13,19],[14,20],[15,21],[16,22],[17,23],[18,24],[19,20],[20,21],[22,23],[23,24],[19,30],[20,29],[21,28],[22,27],[23,26],[24,25],[30,29],[29,28],[27,26],[26,25],[15,22],[21,27],[31,30],[31,29],[32,29],[32,28],[33,27],[33,26],[34,26],[34,25],[31,32],[32,33],[33,34],[31,38],[32,37],[33,36],[34,35],[38,37],[37,36],[36,35],[38,39],[37,40],[36,41],[35,42],[39,40],[40,41],[41,42],[40,43],[41,43],[38,32],[39,37],[37,33],[40,36],[36,34],[41,35]];

let gameState = {
    turn: 'blue',
    selectedNode: null,
    pieces: {
        0:{team:'blue',type:'king'}, 1:{team:'blue',type:'triangle'}, 2:{team:'blue',type:'triangle'}, 3:{team:'blue',type:'triangle'}, 4:{team:'blue',type:'triangle'}, 5:{team:'blue',type:'square'}, 6:{team:'blue',type:'square'}, 7:{team:'blue',type:'square'}, 8:{team:'blue',type:'square'}, 9:{team:'blue',type:'x'}, 10:{team:'blue',type:'x'}, 11:{team:'blue',type:'x'}, 12:{team:'blue',type:'x'},
        43:{team:'red',type:'king'}, 39:{team:'red',type:'triangle'}, 40:{team:'red',type:'triangle'}, 41:{team:'red',type:'triangle'}, 42:{team:'red',type:'triangle'}, 35:{team:'red',type:'square'}, 36:{team:'red',type:'square'}, 37:{team:'red',type:'square'}, 38:{team:'red',type:'square'}, 31:{team:'red',type:'x'}, 32:{team:'red',type:'x'}, 33:{team:'red',type:'x'}, 34:{team:'red',type:'x'}
    }
};

// --- CORE FIX: MOVE VALIDATION ---
function getValidMoves(nodeId) {
    if (nodeId === null) return [];
    const piece = gameState.pieces[nodeId];
    // Find all connected nodes
    let adj = roads.filter(r => r.includes(nodeId)).map(r => r[0] === nodeId ? r[1] : r[0]);
    
    return adj.filter(targetId => {
        const targetPiece = gameState.pieces[targetId];
        // Cannot capture your own team
        if (targetPiece && targetPiece.team === piece.team) return false;
        
        // Rule: X Piece forward only
        if (piece.type === 'x') {
            const isBackward = piece.team === 'blue' ? nodes[targetId].y < nodes[nodeId].y : nodes[targetId].y > nodes[nodeId].y;
            if (isBackward) return false;
        }
        return true;
    });
}

function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw Roads
    ctx.strokeStyle = '#ddd';
    roads.forEach(p => {
        ctx.beginPath(); ctx.moveTo(nodes[p[0]].x, nodes[p[0]].y); ctx.lineTo(nodes[p[1]].x, nodes[p[1]].y); ctx.stroke();
    });

    const possibleMoves = getValidMoves(gameState.selectedNode);

    for (let id in nodes) {
        const n = nodes[id]; const p = gameState.pieces[id];
        const nodeId = parseInt(id);

        // Draw Highlights
        if (gameState.selectedNode === nodeId) {
            ctx.beginPath(); ctx.arc(n.x, n.y, 22, 0, 7); ctx.fillStyle = 'rgba(0, 112, 255, 0.2)'; ctx.fill();
        }
        if (possibleMoves.includes(nodeId)) {
            ctx.beginPath(); ctx.arc(n.x, n.y, 18, 0, 7); ctx.fillStyle = 'rgba(255, 235, 59, 0.5)'; ctx.fill();
        }

        // Draw Node
        ctx.beginPath(); ctx.arc(n.x, n.y, 16, 0, 7); 
        ctx.fillStyle = '#fff'; ctx.fill();
        ctx.strokeStyle = p ? (p.team=='blue'?'#2563EB':'#DC2626') : '#f0f0f0';
        ctx.lineWidth = 2; ctx.stroke();

        if (p) {
            ctx.fillStyle = p.team=='blue'?'#2563EB':'#DC2626';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            let icon = p.type=='king'?'H':p.type=='triangle'?'▲':p.type=='square'?'■':'X';
            ctx.fillText(icon, n.x, n.y + 6);
        }
    }
}

function updateStatus() {
    statusDiv.innerText = gameState.turn.toUpperCase() + "'s Turn";
    statusDiv.style.color = gameState.turn === 'blue' ? '#2563EB' : '#DC2626';
}

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (myRole && gameState.turn !== myRole) return; 
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    for (let id in nodes) {
        const d = Math.sqrt((x-nodes[id].x)**2 + (y-nodes[id].y)**2);
        if (d < 30) { handleInteraction(parseInt(id)); break; }
    }
});

function handleInteraction(id) {
    const targetPiece = gameState.pieces[id];
    
    // If clicking own piece, select it
    if (targetPiece && targetPiece.team === gameState.turn) {
        gameState.selectedNode = id;
    } 
    // If already selected, try to move
    else if (gameState.selectedNode !== null) {
        const valid = getValidMoves(gameState.selectedNode);
        if (valid.includes(id)) {
            if (targetPiece && targetPiece.type === 'king') {
                alert("GAME OVER! " + gameState.turn.toUpperCase() + " WINS!");
                location.reload();
            }
            gameState.pieces[id] = gameState.pieces[gameState.selectedNode];
            delete gameState.pieces[gameState.selectedNode];
            gameState.turn = gameState.turn === 'blue' ? 'red' : 'blue';
            gameState.selectedNode = null;
            sendMove();
        } else {
            gameState.selectedNode = null; // Cancel move if clicking invalid spot
        }
    }
    drawBoard();
    updateStatus();
}

drawBoard();
</script>
</body>
</html>

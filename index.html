<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IQ 17 - Private Match</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #e0e4e8; font-family: sans-serif; text-align: center; overflow: hidden; }
        canvas { 
            border-bottom: 2px solid #ccc; 
            display: block; 
            margin: 0 auto; 
            touch-action: none; 
            background-color: #f0f2f5;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3BaseFilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
            transition: height 0.3s ease; 
        }
        #ui-container { position: fixed; bottom: 0; left: 0; width: 100%; background: #fff; transition: transform 0.3s ease; z-index: 50; box-shadow: 0 -2px 10px rgba(0,0,0,0.1); }
        #ui-container.hidden { transform: translateY(140px); }
        #ui { padding: 10px; background: #fff; height: 140px; box-sizing: border-box; overflow-y: auto; }
        #pull-tab { position: absolute; top: -30px; left: 50%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-bottom: none; padding: 5px 20px; border-radius: 10px 10px 0 0; cursor: pointer; font-size: 12px; font-weight: bold; color: #0088cc; }
        #status { position: absolute; top: -65px; left: 0; width: 100%; font-size: 22px; font-weight: 900; text-transform: uppercase; pointer-events: none; text-shadow: 0px 0px 5px rgba(255,255,255,0.8); }
        .btn { padding: 10px 18px; background: #0088cc; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 3px; font-weight: bold; font-size: 14px; }
        #game-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; flex-direction: column; justify-content: center; align-items: center; color: white; }
        .popup-box { background: white; padding: 30px; border-radius: 15px; color: #333; width: 80%; max-width: 300px; }
        #scoreboard { position: absolute; top: 5px; width: 100%; padding: 0 5px; box-sizing: border-box; pointer-events: none; z-index: 60; display: flex; justify-content: space-between; }
        .score-pill { background: rgba(255, 255, 255, 0.9); padding: 4px 8px; border-radius: 8px; border: 1.5px solid #ccc; width: 100px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; align-items: center; }
        .blue-side { border-color: #2563EB; color: #2563EB; }
        .red-side { border-color: #DC2626; color: #DC2626; }
        .p-name { font-weight: 800; font-size: 10px; text-transform: uppercase; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%; }
        .p-iq { font-size: 9px; font-weight: bold; }
        .p-rank { font-size: 8px; font-style: italic; opacity: 0.9; }
        #iq-change-display { font-size: 18px; font-weight: bold; margin: 15px 0; display: block; }
    </style>
</head>
<body>

    <div id="scoreboard">
        <div id="blue-pill" class="score-pill blue-side">
            <span id="blue-name" class="p-name">BLUE</span>
            <span class="p-iq">IQ: <span id="blue-iq-val">30</span></span>
            <span id="blue-rank" class="p-rank">Initiate</span>
        </div>
        <div id="red-pill" class="score-pill red-side">
            <span id="red-name" class="p-name">RED</span>
            <span class="p-iq">IQ: <span id="red-iq-val">?</span></span>
            <span id="red-rank" class="p-rank">---</span>
        </div>
    </div>

    <div id="game-overlay">
        <div class="popup-box">
            <h2 id="win-message">BLUE WINS!</h2>
            <div id="iq-change-display"></div>
            <div id="popup-controls">
                <button id="rematch-btn-ui" class="btn" style="background:#00AD11" onclick="handleRematchRequest()">Request Rematch</button>
                <button class="btn" style="background:#888" onclick="document.getElementById('game-overlay').style.display='none'">Close</button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-container">
        <div id="status">Connecting...</div>
        <div id="pull-tab" onclick="toggleUI()">â–² MENU</div>
        <div id="ui">
            <div id="menu">
                <button id="invite-player-btn" class="btn" onclick="inviteTelegramFriend('player')">Invite Friend</button>
                <button id="invite-spec-btn" class="btn" style="background:#555" onclick="inviteTelegramFriend('spectator')">Spectators</button>
                <br>
                <button id="surrender-btn" class="btn" style="background:#DC2626" onclick="handleSurrender()">Surrender</button>
                <button id="draw-btn" class="btn" style="background:#f39c12" onclick="handleDrawRequest()">Offer Draw</button>
            </div>
        </div>
    </div>

<script>
const tg = window.Telegram.WebApp;
tg.expand();

const myTelegramName = tg.initDataUnsafe.user ? tg.initDataUnsafe.user.first_name : "Player";

function getRank(iq) {
    if (iq <= 50) return "Initiate";
    if (iq <= 70) return "Strategist";
    if (iq <= 85) return "Mastermind";
    return "Conqueror";
}

let userScore = 30;

function loadScore() {
    tg.CloudStorage.getItem('player_iq_final_v1', (err, value) => {
        if (!err && value) userScore = parseInt(value);
        else userScore = 30;
        updateScoreboardDisplay();
        syncMyInfo();
    });
}

function updateScoreboardDisplay() {
    const side = myRole === 'blue' ? 'blue' : 'red';
    const nameEl = document.getElementById(`${side}-name`);
    const iqEl = document.getElementById(`${side}-iq-val`);
    const rankEl = document.getElementById(`${side}-rank`);
    if(nameEl) nameEl.innerText = myTelegramName;
    if(iqEl) iqEl.innerText = userScore;
    if(rankEl) rankEl.innerText = getRank(userScore);
}

function updateScore(isWin, isDraw = false) {
    const display = document.getElementById('iq-change-display');
    const isSolo = (myRole === 'blue' && !isRedAssigned);
    
    if (isSolo || isDraw) {
        display.innerText = isDraw ? "Match Draw: No IQ Change" : "Solo Match: No IQ Change";
        display.style.color = "#888";
        return;
    }

    let change = 0;
    if (isWin) {
        if (userScore < 50) change = 10;
        else if (userScore < 70) change = 5;
        else if (userScore < 85) change = 3;
        else if (userScore < 100) change = 1;
        userScore = Math.min(100, userScore + change);
        display.innerText = `+${change} IQ Gained!`;
        display.style.color = "#00AD11";
    } else {
        if (userScore <= 50) change = 10;
        else if (userScore <= 70) change = 15;
        else if (userScore <= 85) change = 20;
        else if (userScore <= 100) change = 25;
        userScore = Math.max(0, userScore - change);
        display.innerText = `-${change} IQ Lost`;
        display.style.color = "#DC2626";
    }
    updateScoreboardDisplay();
    tg.CloudStorage.setItem('player_iq_final_v1', userScore.toString());
    syncMyInfo();
}

function handleSurrender() {
    if (gameState.gameOver || (myRole === 'blue' && !isRedAssigned)) return;
    tg.showConfirm("Surrender and lose IQ?", (ok) => {
        if (ok && conn && conn.open) {
            gameState.gameOver = true;
            gameState.winner = (myRole === 'blue' ? 'red' : 'blue');
            conn.send({ type: 'SURRENDER', winner: gameState.winner });
            updateScore(false);
            showWinPopup(gameState.winner);
            winMsg.innerText = "YOU SURRENDERED";
        }
    });
}

function handleDrawRequest() {
    if (gameState.gameOver || (myRole === 'blue' && !isRedAssigned)) return;
    if (conn && conn.open) {
        conn.send({ type: 'DRAW_OFFER' });
        tg.showAlert("Draw offer sent.");
    }
}

function handleRematchRequest() {
    if (conn && conn.open) {
        conn.send({ type: 'REMATCH_OFFER' });
        tg.showAlert("Rematch request sent.");
    }
}

function triggerRestart() {
    gameState = initialGameState();
    overlay.style.display = 'none';
    if (myRole === 'blue') broadcastState(); 
    drawBoard();
    updateStatus();
}

function syncMyInfo() {
    if (conn && conn.open) {
        conn.send({ type: 'INFO_SYNC', name: myTelegramName, iq: userScore, role: myRole });
    }
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusDiv = document.getElementById('status');
const overlay = document.getElementById('game-overlay');
const winMsg = document.getElementById('win-message');
const uiContainer = document.getElementById('ui-container');
const pullTab = document.getElementById('pull-tab');
const invitePlayerBtn = document.getElementById('invite-player-btn');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 140;
const scaleX = canvas.width / 400;
const scaleY = canvas.height / 700;

const nodes = {
    0: {x: 200*scaleX, y: 50*scaleY}, 1: {x: 80*scaleX, y: 110*scaleY}, 2: {x: 160*scaleX, y: 110*scaleY}, 3: {x: 240*scaleX, y: 110*scaleY}, 4: {x: 320*scaleX, y: 110*scaleY}, 
    5: {x: 80*scaleX, y: 180*scaleY}, 6: {x: 160*scaleX, y: 180*scaleY}, 7: {x: 240*scaleX, y: 180*scaleY}, 8: {x: 320*scaleX, y: 180*scaleY}, 
    9: {x: 80*scaleX, y: 250*scaleY}, 10: {x: 160*scaleX, y: 250*scaleY}, 11: {x: 240*scaleX, y: 250*scaleY}, 12: {x: 320*scaleX, y: 250*scaleY}, 
    13: {x: 25*scaleX, y: 315*scaleY}, 14: {x: 102.5*scaleX, y: 315*scaleY}, 15: {x: 180*scaleX, y: 315*scaleY}, 16: {x: 220*scaleX, y: 315*scaleY}, 17: {x: 297.5*scaleX, y: 315*scaleY}, 18: {x: 375*scaleX, y: 315*scaleY}, 
    19: {x: 25*scaleX, y: 375*scaleY}, 20: {x: 102.5*scaleX, y: 375*scaleY}, 21: {x: 180*scaleX, y: 375*scaleY}, 22: {x: 220*scaleX, y: 375*scaleY}, 23: {x: 297.5*scaleX, y: 375*scaleY}, 24: {x: 375*scaleX, y: 375*scaleY}, 
    30: {x: 25*scaleX, y: 435*scaleY}, 29: {x: 102.5*scaleX, y: 435*scaleY}, 28: {x: 180*scaleX, y: 435*scaleY}, 27: {x: 220*scaleX, y: 435*scaleY}, 26: {x: 297.5*scaleX, y: 435*scaleY}, 25: {x: 375*scaleX, y: 435*scaleY}, 
    31: {x: 80*scaleX, y: 500*scaleY}, 32: {x: 160*scaleX, y: 500*scaleY}, 33: {x: 240*scaleX, y: 500*scaleY}, 34: {x: 320*scaleX, y: 500*scaleY}, 
    38: {x: 80*scaleX, y: 570*scaleY}, 37: {x: 160*scaleX, y: 570*scaleY}, 36: {x: 240*scaleX, y: 570*scaleY}, 35: {x: 320*scaleX, y: 570*scaleY}, 
    39: {x: 80*scaleX, y: 640*scaleY}, 40: {x: 160*scaleX, y: 640*scaleY}, 41: {x: 240*scaleX, y: 640*scaleY}, 42: {x: 320*scaleX, y: 640*scaleY}, 43: {x: 200*scaleX, y: 690*scaleY}
};

const roads = [[0,2],[0,3],[1,2],[2,3],[3,4],[1,5],[2,6],[3,7],[4,8],[5,6],[6,7],[7,8],[5,9],[6,10],[7,11],[8,12],[9,10],[10,11],[11,12],[2,5],[3,6],[6,9],[4,7],[7,10],[8,11],[9,13],[9,14],[10,14],[10,15],[11,16],[11,17],[12,18],[12,17],[13,14],[14,15],[16,17],[17,18],[13,19],[14,20],[15,21],[16,22],[17,23],[18,24],[19,20],[20,21],[22,23],[23,24],[19,30],[20,29],[21,28],[22,27],[23,26],[24,25],[30,29],[29,28],[27,26],[26,25],[15,22],[21,27],[31,30],[31,29],[32,29],[32,28],[33,27],[33,26],[34,26],[34,25],[31,32],[32,33],[33,34],[31,38],[32,37],[33,36],[34,35],[38,37],[37,36],[36,35],[38,39],[37,40],[36,41],[35,42],[39,40],[40,41],[41,42],[40,43],[41,43],[38,32],[39,37],[37,33],[40,36],[36,34],[41,35],[18,23],[23,27],[16,23],[23,25],[13,20],[20,28],[15,20],[20,30]];

let peer = new Peer({ config: {'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }, { 'urls': 'turn:global.relay.metered.ca:443', 'username': '12086455af0334c526b9d3da', 'credential': 'ZxLMG6ZJX9R7oyQE' }], 'iceTransportPolicy': 'relay' } });
let conn = null, spectators = [], myRole = null, isRedAssigned = false, isJustConnected = false;

const initialGameState = () => ({
    turn: 'blue', selectedNode: null, lastMove: null, gameOver: false, winner: null,
    pieces: {
        0:{team:'blue',type:'king'}, 3:{team:'blue',type:'triangle'}, 4:{team:'blue',type:'triangle'},
        5:{team:'blue',type:'square'}, 6:{team:'blue',type:'square'}, 7:{team:'blue',type:'square'}, 8:{team:'blue',type:'square'},
        9:{team:'blue',type:'x'}, 10:{team:'blue',type:'x'}, 11:{team:'blue',type:'x'}, 12:{team:'blue',type:'x'},
        43:{team:'red',type:'king'}, 39:{team:'red',type:'triangle'}, 40:{team:'red',type:'triangle'},
        35:{team:'red',type:'square'}, 36:{team:'red',type:'square'}, 37:{team:'red',type:'square'}, 38:{team:'red',type:'square'},
        31:{team:'red',type:'x'}, 32:{team:'red',type:'x'}, 33:{team:'red',type:'x'}, 34:{team:'red',type:'x'}
    }
});
let gameState = initialGameState();

function getValidMoves(startNode) {
    if (startNode === null) return [];
    const piece = gameState.pieces[startNode];
    let valid = [], visited = new Map();
    const isSpecialPiece = (piece.type === 'triangle' || piece.type === 'king');
    const maxDist = isSpecialPiece ? 3 : 1; 
    let queue = [{id: startNode, dist: 0, lastNode: null}];
    visited.set(startNode, 0);
    while (queue.length > 0) {
        let current = queue.shift();
        if (current.dist >= maxDist) continue;
        let neighbors = roads.filter(r => r.includes(current.id)).map(r => r[0] === current.id ? r[1] : r[0]);
        neighbors.forEach(neighbor => {
            if (neighbor === 0 || neighbor === 43) {
                const targetPiece = gameState.pieces[neighbor];
                if (piece.type !== 'king') {
                    const isEnemyChamber = (piece.team === 'blue' && neighbor === 43) || (piece.team === 'red' && neighbor === 0);
                    if (isEnemyChamber) { if (!targetPiece || targetPiece.team === piece.team) return; } else { return; }
                } else { if (targetPiece && targetPiece.team === piece.team) return; }
            }
            if (isSpecialPiece && current.lastNode !== null) {
                // SPECIAL EXCEPTIONS FOR NODES 38->28 AND 8->16
                const isException38to28 = (current.id === 38 && neighbor === 28);
                const isException8to16 = (current.id === 8 && neighbor === 16);
                
                if (!isException38to28 && !isException8to16) {
                    const p1 = nodes[current.lastNode], p2 = nodes[current.id], p3 = nodes[neighbor];
                    const angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x), angle2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
                    let diff = Math.abs(angle1 - angle2);
                    if (diff > Math.PI) diff = 2 * Math.PI - diff;
                    if ((diff * 180 / Math.PI) > 17) return; // Zigzag Turn Rule
                }
            }
            if (!visited.has(neighbor)) {
                const targetPiece = gameState.pieces[neighbor];
                if (piece.type === 'x') {
                    const isBackward = piece.team === 'blue' ? nodes[neighbor].y < nodes[startNode].y : nodes[neighbor].y > nodes[startNode].y;
                    const isBridge = (startNode == 15 && neighbor == 22) || (startNode == 22 && neighbor == 15) || (startNode == 21 && neighbor == 27) || (startNode == 27 && neighbor == 21);
                    if (isBackward && (!isBridge || !targetPiece || targetPiece.team === piece.team)) return;
                    if (targetPiece && targetPiece.type === 'square') return;
                }
                if (targetPiece) {
                    if (targetPiece.team !== piece.team) valid.push(neighbor);
                    visited.set(neighbor, current.dist + 1);
                } else {
                    valid.push(neighbor); visited.set(neighbor, current.dist + 1);
                    queue.push({id: neighbor, dist: current.dist + 1, lastNode: current.id});
                }
            }
        });
    }
    return [...new Set(valid)];
}

function handleInteraction(id) {
    if (gameState.gameOver || myRole === 'spectator') return;
    const isHostSolo = (myRole === 'blue' && !isRedAssigned);
    const isYourTurn = (myRole && gameState.turn === myRole);
    if (!isYourTurn && !isHostSolo) return;
    const target = gameState.pieces[id];
    if (target && target.team === gameState.turn) {
        gameState.selectedNode = id;
    } else if (gameState.selectedNode !== null) {
        if (getValidMoves(gameState.selectedNode).includes(id)) {
            const movingPiece = gameState.pieces[gameState.selectedNode];
            if ((target && target.type === 'king') || (movingPiece.type === 'king' && ((movingPiece.team === 'blue' && id === 43) || (movingPiece.team === 'red' && id === 0)))) {
                gameState.gameOver = true; gameState.winner = gameState.turn; 
                if (myRole === gameState.turn) updateScore(true);
                else if (myRole !== null && myRole !== 'spectator') updateScore(false);
                showWinPopup(gameState.winner);
            }
            gameState.lastMove = {from: gameState.selectedNode, to: id};
            gameState.pieces[id] = movingPiece; delete gameState.pieces[gameState.selectedNode];
            gameState.turn = gameState.turn === 'blue' ? 'red' : 'blue'; gameState.selectedNode = null; 
            broadcastState(); updateStatus();
        } else { gameState.selectedNode = null; }
    }
    drawBoard();
}

function drawBoard(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.strokeStyle='#7a869a';ctx.lineWidth=2.5;roads.forEach(p=>{ctx.beginPath();ctx.moveTo(nodes[p[0]].x,nodes[p[0]].y);ctx.lineTo(nodes[p[1]].x,nodes[p[1]].y);ctx.stroke()});const possible=getValidMoves(gameState.selectedNode);for(let id in nodes){const n=nodes[id], p=gameState.pieces[id], numId=parseInt(id);if(gameState.lastMove&&(gameState.lastMove.from===numId||gameState.lastMove.to===numId)){ctx.beginPath();ctx.arc(n.x,n.y,24,0,7);ctx.fillStyle='rgba(0,0,0,0.08)';ctx.fill()}if(gameState.selectedNode===numId){ctx.beginPath();ctx.arc(n.x,n.y,24,0,7);ctx.fillStyle='rgba(0,112,255,0.2)';ctx.fill()}if(possible.includes(numId)){ctx.beginPath();ctx.arc(n.x,n.y,20,0,7);ctx.fillStyle='rgba(255,160,0,0.6)';ctx.fill();ctx.strokeStyle='rgba(180,120,0,0.7)';ctx.lineWidth=2;ctx.stroke()}
if(p){ctx.shadowBlur=12;ctx.shadowColor=p.team=='blue'?'rgba(37,99,235,0.7)':'rgba(220,38,38,0.7)';}else{ctx.shadowBlur=0;}
if(p&&p.type==='king'){drawHex(n.x,n.y,20);ctx.fillStyle='#fff';ctx.fill();ctx.strokeStyle=p.team=='blue'?'#2563EB':'#DC2626';ctx.lineWidth=3;ctx.stroke()}else{ctx.beginPath();ctx.arc(n.x,n.y,16,0,7);ctx.fillStyle='#fff';ctx.fill();ctx.strokeStyle=p?(p.team=='blue'?'#2563EB':'#DC2626'):'#c1c7d0';ctx.lineWidth=2;ctx.stroke()}if(p){ctx.fillStyle=p.team=='blue'?'#2563EB':'#DC2626';ctx.font='bold 18px Arial';ctx.textAlign='center';let icon=p.type=='king'?'ðŸ‘‘':p.type=='triangle'?'â–²':p.type=='square'?'â– ':'X';ctx.fillText(icon,n.x,n.y+(p.type=='king'?7:6))}ctx.shadowBlur=0;}}
function drawHex(x,y,size){ctx.beginPath();for(let i=0;i<6;i++){ctx.lineTo(x+size*Math.cos(i*Math.PI/3),y+size*Math.sin(i*Math.PI/3))}ctx.closePath()}
function toggleUI(f=false){if(f || !uiContainer.classList.contains('hidden')){ uiContainer.classList.add('hidden'); pullTab.innerText="â–² MENU"; canvas.height=window.innerHeight; }else{ uiContainer.classList.remove('hidden'); pullTab.innerText="â–¼ CLOSE"; canvas.height=window.innerHeight-140; }drawBoard();}

function broadcastState(){if(conn&&conn.open) { conn.send(gameState); syncMyInfo(); } spectators.forEach(s=>{if(s.open)s.send(gameState)})}
function updateStatus(){if(gameState.gameOver)return;if(isJustConnected){ statusDiv.innerText = "CONNECTED"; statusDiv.style.color = "#00AD11"; return; }let prefix = (myRole==='spectator'?"LIVE: ":"");if (myRole === 'blue' && !isRedAssigned) prefix = "SOLO: ";statusDiv.innerText=prefix+gameState.turn.toUpperCase()+" TURN";statusDiv.style.color=gameState.turn==='blue'?'#2563EB':'#DC2626';}
function showWinPopup(w){if(w==='draw'){winMsg.innerText="MATCH DRAW!";winMsg.style.color="#888";}else{winMsg.innerText=w.toUpperCase()+" WINS!";winMsg.style.color=w==='blue'?'#2563EB':'#DC2626';}document.getElementById('popup-controls').style.display='block';overlay.style.display='flex'}
function showFullRoomPopup(){winMsg.innerText="ROOM FULL - SPECTATING";winMsg.style.color="#333";winMsg.style.fontSize="18px";document.getElementById('popup-controls').style.display='none';overlay.style.display='flex';}
function inviteTelegramFriend(t){const l=`https://t.me/Iq17game_bot/IQ17?startapp=${t==='spectator'?'spec_'+peer.id:peer.id}`;tg.openTelegramLink(`https://t.me/share/url?url=${encodeURIComponent(l)}&text=${encodeURIComponent(t==='spectator'?"Watch live!":"Challenge me!")}`)}

function setupConnection(){
    conn.on('open',()=>{
        syncMyInfo();
        if(myRole==='red'){ conn.send({type: 'CHECK_AVAILABILITY'}); invitePlayerBtn.style.display='none'; isJustConnected=true; updateStatus(); setTimeout(()=> {isJustConnected=false; updateStatus();}, 2000); }
    });
    
    conn.on('close', () => {
        if(!gameState.gameOver && isRedAssigned) {
            gameState.gameOver = true;
            gameState.winner = myRole;
            updateScore(true);
            showWinPopup(gameState.winner);
            winMsg.innerText = "OPPONENT LEFT - YOU WIN!";
        }
    });

    conn.on('data',d=>{
        if(!d || typeof d !== 'object') return;
        
        // Handle Commands
        if(d.type) {
            switch(d.type) {
                case 'INFO_SYNC':
                    const side = d.role === 'blue' ? 'blue' : 'red';
                    const nameEl = document.getElementById(`${side}-name`);
                    const iqEl = document.getElementById(`${side}-iq-val`);
                    const rankEl = document.getElementById(`${side}-rank`);
                    if(nameEl) nameEl.innerText = d.name;
                    if(iqEl) iqEl.innerText = d.iq;
                    if(rankEl) rankEl.innerText = getRank(d.iq);
                    break;
                case 'SURRENDER':
                    gameState.gameOver = true;
                    gameState.winner = d.winner;
                    updateScore(myRole === d.winner);
                    showWinPopup(gameState.winner);
                    winMsg.innerText = "OPPONENT SURRENDERED!";
                    break;
                case 'DRAW_OFFER':
                    tg.showConfirm("Opponent offered a draw. Accept?", (ok) => {
                        if(ok && conn && conn.open) {
                            gameState.gameOver = true;
                            gameState.winner = 'draw';
                            conn.send({ type: 'DRAW_ACCEPT' });
                            updateScore(false, true);
                            showWinPopup('draw');
                        }
                    });
                    break;
                case 'DRAW_ACCEPT':
                    gameState.gameOver = true;
                    gameState.winner = 'draw';
                    updateScore(false, true);
                    showWinPopup('draw');
                    break;
                case 'REMATCH_OFFER':
                    tg.showConfirm("Opponent wants a rematch. Accept?", (ok) => {
                        if(ok && conn && conn.open) {
                            conn.send({ type: 'REMATCH_ACCEPT' });
                            triggerRestart();
                        }
                    });
                    break;
                case 'REMATCH_ACCEPT':
                    triggerRestart();
                    break;
                case 'ROOM_FULL':
                    showFullRoomPopup();
                    conn.close();
                    break;
                case 'CHECK_AVAILABILITY':
                    if(isRedAssigned) { conn.send({type: "ROOM_FULL"}); }
                    else { 
                        isRedAssigned=true; 
                        invitePlayerBtn.style.display='none'; 
                        isJustConnected=true; 
                        updateStatus(); 
                        setTimeout(()=> {isJustConnected=false; updateStatus();}, 2000); 
                        broadcastState(); 
                    }
                    break;
            }
            return;
        }

        // Handle Game State (if no type property)
        gameState=d; 
        spectators.forEach(s=>{if(s.open)s.send(gameState)});
        if(gameState.gameOver) {
            if(myRole !== 'spectator' && myRole !== null) {
                if(gameState.winner === 'draw') updateScore(false, true);
                else if(gameState.winner !== myRole) updateScore(false);
                else updateScore(true);
            }
            showWinPopup(gameState.winner);
        }
        drawBoard(); updateStatus();
    });
}

peer.on('open',id=>{
    const p=tg.initDataUnsafe.start_param;
    if(p){
        if(p.startsWith('spec_')){ conn=peer.connect(p.replace('spec_',''),{metadata:{type:'spectator'},reliable:true}); myRole='spectator'; }
        else{ conn=peer.connect(p,{reliable:true}); myRole='red'; }
        setupConnection();
    }else{ myRole='blue'; updateStatus(); }
    loadScore();
});

peer.on('connection',c=>{
    if(c.metadata&&c.metadata.type==='spectator'){ spectators.push(c); c.on('open',()=>c.send(gameState)); }
    else{
        if(myRole === 'blue' && isRedAssigned) { c.on('open', () => c.send({type: "ROOM_FULL"})); return; }
        conn=c; setupConnection();
    }
});

canvas.addEventListener('touchstart',e=>{
    e.preventDefault(); toggleUI(true);
    const t=e.touches[0], r=canvas.getBoundingClientRect();
    const x=t.clientX-r.left, y=t.clientY-r.top;
    for(let id in nodes){if(Math.sqrt((x-nodes[id].x)**2+(y-nodes[id].y)**2)<30){handleInteraction(parseInt(id));break}}
});
drawBoard();
</script>
</body>
</html>

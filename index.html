<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IQ 17 - Private Match</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #e0e4e8; font-family: sans-serif; text-align: center; overflow: hidden; }
        canvas { border-bottom: 2px solid #ccc; display: block; margin: 0 auto; touch-action: none; background-color: #f0f2f5; transition: height 0.3s ease; }
        #ui-container { position: fixed; bottom: 0; left: 0; width: 100%; background: #fff; transition: transform 0.3s ease; z-index: 50; box-shadow: 0 -2px 10px rgba(0,0,0,0.1); }
        #ui-container.hidden { transform: translateY(140px); }
        #ui { padding: 10px; background: #fff; height: 140px; box-sizing: border-box; overflow-y: auto; }
        #pull-tab { position: absolute; top: -30px; left: 50%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-bottom: none; padding: 5px 20px; border-radius: 10px 10px 0 0; cursor: pointer; font-size: 12px; font-weight: bold; color: #0088cc; }
        #status { position: absolute; top: -65px; left: 0; width: 100%; font-size: 22px; font-weight: 900; text-transform: uppercase; pointer-events: none; text-shadow: 0px 0px 5px rgba(255,255,255,0.8); }
        .btn { padding: 10px 18px; background: #0088cc; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 3px; font-weight: bold; font-size: 14px; }
        #game-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; flex-direction: column; justify-content: center; align-items: center; color: white; }
        .popup-box { background: white; padding: 30px; border-radius: 15px; color: #333; width: 80%; max-width: 300px; }
        #scoreboard { position: absolute; top: 5px; width: 100%; padding: 0 5px; box-sizing: border-box; pointer-events: none; z-index: 60; display: flex; justify-content: space-between; }
        .score-pill { background: rgba(255, 255, 255, 0.9); padding: 4px 8px; border-radius: 8px; border: 1.5px solid #ccc; width: 100px; display: flex; flex-direction: column; align-items: center; }
    </style>
</head>
<body>

    <div id="scoreboard">
        <div id="blue-pill" class="score-pill" style="color:#2563EB"><span id="blue-name" style="font-weight:800">BLUE</span><span style="font-size:9px">IQ: <span id="blue-iq-val">30</span></span></div>
        <div id="red-pill" class="score-pill" style="color:#DC2626"><span id="red-name" style="font-weight:800">RED</span><span style="font-size:9px">IQ: <span id="red-iq-val">?</span></span></div>
    </div>

    <div id="game-overlay">
        <div class="popup-box">
            <h2 id="win-message">WINS!</h2>
            <div id="iq-change-display" style="font-size:18px; font-weight:bold; margin:15px 0;"></div>
            <button class="btn" style="background:#00AD11" onclick="location.reload()">New Match</button>
            <button class="btn" style="background:#888" onclick="document.getElementById('game-overlay').style.display='none'">Close</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-container">
        <div id="status">Connecting...</div>
        <div id="pull-tab" onclick="toggleUI()">▲ MENU</div>
        <div id="ui">
            <button id="invite-btn" class="btn" onclick="inviteTelegramFriend()">Invite Friend</button>
            <button class="btn" style="background:#DC2626" onclick="handleSurrender()">Surrender</button>
            <button class="btn" style="background:#f39c12" onclick="handleDrawRequest()">Offer Draw</button>
        </div>
    </div>

<script>
const tg = window.Telegram.WebApp;
tg.expand();
const myTelegramName = tg.initDataUnsafe.user ? tg.initDataUnsafe.user.first_name : "Player";
let userScore = 30;
let peer = new Peer({ config: {'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }, { 'urls': 'turn:global.relay.metered.ca:443', 'username': '12086455af0334c526b9d3da', 'credential': 'ZxLMG6ZJX9R7oyQE' }] } });
let conn = null, spectators = [], myRole = null, isRedAssigned = false;

const initialGameState = () => ({
    turn: 'blue', selectedNode: null, lastMove: null, gameOver: false, winner: null,
    pieces: {
        0:{team:'blue',type:'king'}, 3:{team:'blue',type:'triangle'}, 4:{team:'blue',type:'triangle'},
        5:{team:'blue',type:'square'}, 6:{team:'blue',type:'square'}, 7:{team:'blue',type:'square'}, 8:{team:'blue',type:'square'},
        9:{team:'blue',type:'x'}, 10:{team:'blue',type:'x'}, 11:{team:'blue',type:'x'}, 12:{team:'blue',type:'x'},
        43:{team:'red',type:'king'}, 39:{team:'red',type:'triangle'}, 40:{team:'red',type:'triangle'},
        35:{team:'red',type:'square'}, 36:{team:'red',type:'square'}, 37:{team:'red',type:'square'}, 38:{team:'red',type:'square'},
        31:{team:'red',type:'x'}, 32:{team:'red',type:'x'}, 33:{team:'red',type:'x'}, 34:{team:'red',type:'x'}
    }
});
let gameState = initialGameState();

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 140;
const scaleX = canvas.width / 400; const scaleY = canvas.height / 700;

const nodes = {
    0: {x: 200*scaleX, y: 50*scaleY}, 1: {x: 80*scaleX, y: 110*scaleY}, 2: {x: 160*scaleX, y: 110*scaleY}, 3: {x: 240*scaleX, y: 110*scaleY}, 4: {x: 320*scaleX, y: 110*scaleY}, 
    5: {x: 80*scaleX, y: 180*scaleY}, 6: {x: 160*scaleX, y: 180*scaleY}, 7: {x: 240*scaleX, y: 180*scaleY}, 8: {x: 320*scaleX, y: 180*scaleY}, 
    9: {x: 80*scaleX, y: 250*scaleY}, 10: {x: 160*scaleX, y: 250*scaleY}, 11: {x: 240*scaleX, y: 250*scaleY}, 12: {x: 320*scaleX, y: 250*scaleY}, 
    13: {x: 25*scaleX, y: 315*scaleY}, 14: {x: 102.5*scaleX, y: 315*scaleY}, 15: {x: 180*scaleX, y: 315*scaleY}, 16: {x: 220*scaleX, y: 315*scaleY}, 17: {x: 297.5*scaleX, y: 315*scaleY}, 18: {x: 375*scaleX, y: 315*scaleY}, 
    19: {x: 25*scaleX, y: 375*scaleY}, 20: {x: 102.5*scaleX, y: 375*scaleY}, 21: {x: 180*scaleX, y: 375*scaleY}, 22: {x: 220*scaleX, y: 375*scaleY}, 23: {x: 297.5*scaleX, y: 375*scaleY}, 24: {x: 375*scaleX, y: 375*scaleY}, 
    30: {x: 25*scaleX, y: 435*scaleY}, 29: {x: 102.5*scaleX, y: 435*scaleY}, 28: {x: 180*scaleX, y: 435*scaleY}, 27: {x: 220*scaleX, y: 435*scaleY}, 26: {x: 297.5*scaleX, y: 435*scaleY}, 25: {x: 375*scaleX, y: 435*scaleY}, 
    31: {x: 80*scaleX, y: 500*scaleY}, 32: {x: 160*scaleX, y: 500*scaleY}, 33: {x: 240*scaleX, y: 500*scaleY}, 34: {x: 320*scaleX, y: 500*scaleY}, 
    38: {x: 80*scaleX, y: 570*scaleY}, 37: {x: 160*scaleX, y: 570*scaleY}, 36: {x: 240*scaleX, y: 570*scaleY}, 35: {x: 320*scaleX, y: 570*scaleY}, 
    39: {x: 80*scaleX, y: 640*scaleY}, 40: {x: 160*scaleX, y: 640*scaleY}, 41: {x: 240*scaleX, y: 640*scaleY}, 42: {x: 320*scaleX, y: 640*scaleY}, 43: {x: 200*scaleX, y: 690*scaleY}
};

const roads = [[0,2],[0,3],[1,2],[2,3],[3,4],[1,5],[2,6],[3,7],[4,8],[5,6],[6,7],[7,8],[5,9],[6,10],[7,11],[8,12],[9,10],[10,11],[11,12],[2,5],[3,6],[6,9],[4,7],[7,10],[8,11],[9,13],[9,14],[10,14],[10,15],[11,16],[11,17],[12,18],[12,17],[13,14],[14,15],[16,17],[17,18],[13,19],[14,20],[15,21],[16,22],[17,23],[18,24],[19,20],[20,21],[22,23],[23,24],[19,30],[20,29],[21,28],[22,27],[23,26],[24,25],[30,29],[29,28],[27,26],[26,25],[15,22],[21,27],[31,30],[31,29],[32,29],[32,28],[33,27],[33,26],[34,26],[34,25],[31,32],[32,33],[33,34],[31,38],[32,37],[33,36],[34,35],[38,37],[37,36],[36,35],[38,39],[37,40],[36,41],[35,42],[39,40],[40,41],[41,42],[40,43],[41,43],[38,32],[39,37],[37,33],[40,36],[36,34],[41,35],[18,23],[23,27],[16,23],[23,25],[13,20],[20,28],[15,20],[20,30]];

function getValidMoves(startNode) {
    if (startNode === null) return [];
    const piece = gameState.pieces[startNode];
    let valid = [], visited = new Map();
    const isSpecial = (piece.type === 'triangle' || piece.type === 'king');
    let queue = [{id: startNode, dist: 0, lastNode: null}];
    visited.set(startNode, 0);
    while (queue.length > 0) {
        let current = queue.shift();
        if (current.dist >= (isSpecial ? 3 : 1)) continue;
        let neighbors = roads.filter(r => r.includes(current.id)).map(r => r[0] === current.id ? r[1] : r[0]);
        neighbors.forEach(neighbor => {
            if (isSpecial && current.lastNode !== null) {
                const p1 = nodes[current.lastNode], p2 = nodes[current.id], p3 = nodes[neighbor];
                let angle = Math.abs(Math.atan2(p2.y-p1.y, p2.x-p1.x) - Math.atan2(p3.y-p2.y, p3.x-p2.x)) * 180 / Math.PI;
                if (angle > 180) angle = 360 - angle;
                if (angle > 17) return; // ZIGZAG RULE: 17 DEGREES
            }
            if (!visited.has(neighbor)) {
                const target = gameState.pieces[neighbor];
                if (target) { if(target.team !== piece.team) valid.push(neighbor); }
                else { valid.push(neighbor); queue.push({id: neighbor, dist: current.dist+1, lastNode: current.id}); }
                visited.set(neighbor, current.dist+1);
            }
        });
    }
    return valid;
}

function handleInteraction(id) {
    if (gameState.gameOver || myRole === 'spectator' || (myRole && gameState.turn !== myRole)) return;
    const idNum = parseInt(id);
    const target = gameState.pieces[idNum];
    if (target && target.team === gameState.turn) {
        gameState.selectedNode = idNum;
    } else if (gameState.selectedNode !== null && getValidMoves(gameState.selectedNode).includes(idNum)) {
        if (target && target.type === 'king') endGame(gameState.turn, 'CHECKMATE');
        gameState.pieces[idNum] = gameState.pieces[gameState.selectedNode];
        delete gameState.pieces[gameState.selectedNode];
        gameState.turn = gameState.turn === 'blue' ? 'red' : 'blue';
        gameState.selectedNode = null;
        broadcastState();
    }
    drawBoard();
}

function endGame(winner, reason) {
    if (gameState.gameOver) return;
    gameState.gameOver = true;
    gameState.winner = winner;
    const report = { type: 'GAME_OVER_REPORT', winner, reason };
    if (conn && conn.open) conn.send(report);
    spectators.forEach(s => s.open && s.send(report));
    showWinPopup(winner, reason);
    if (myRole && myRole !== 'spectator') updateScore(myRole === winner);
}

function showWinPopup(w, reason) {
    const msg = document.getElementById('win-message');
    if (reason === 'DISCONNECT') msg.innerText = "OPPONENT LEFT - YOU WIN!";
    else if (reason === 'SURRENDER') msg.innerText = (w === myRole ? "OPPONENT SURRENDERED" : "YOU SURRENDERED");
    else if (w === 'draw') msg.innerText = "MATCH DRAW";
    else msg.innerText = (w === myRole ? "YOU WON!" : "YOU LOST!");
    document.getElementById('game-overlay').style.display = 'flex';
}

function updateScore(win) {
    userScore += win ? 10 : -15;
    document.getElementById(myRole + '-iq-val').innerText = userScore;
    tg.CloudStorage.setItem('player_iq_final_v1', userScore.toString());
}

function setupConnection() {
    conn.on('open', () => { 
        syncMyInfo(); 
        if(myRole === 'red') conn.send({type:'CHECK_AVAILABILITY'});
        document.getElementById('status').innerText = "CONNECTED";
    });
    conn.on('close', () => { if(!gameState.gameOver && isRedAssigned) endGame(myRole, 'DISCONNECT'); });
    conn.on('data', d => {
        if (d.type === 'GAME_OVER_REPORT') { gameState.gameOver = true; showWinPopup(d.winner, d.reason); }
        else if (d.type === 'DRAW_OFFER') { tg.showConfirm("Accept Draw?", ok => ok && endGame('draw', 'DRAW')); }
        else if (d.type === 'INFO_SYNC') { document.getElementById(d.role + '-name').innerText = d.name; document.getElementById(d.role + '-iq-val').innerText = d.iq; }
        else if (d.type === 'CHECK_AVAILABILITY') { if(isRedAssigned) conn.send({type:'ROOM_FULL'}); else { isRedAssigned = true; broadcastState(); } }
        else { gameState = d; drawBoard(); updateStatus(); }
    });
}

function drawBoard() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = '#7a869a'; ctx.lineWidth = 2;
    roads.forEach(r => {
        ctx.beginPath(); ctx.moveTo(nodes[r[0]].x, nodes[r[0]].y);
        ctx.lineTo(nodes[r[1]].x, nodes[r[1]].y); ctx.stroke();
    });
    const possible = getValidMoves(gameState.selectedNode);
    for(let id in nodes) {
        const n = nodes[id], p = gameState.pieces[id];
        if (possible.includes(parseInt(id))) { ctx.beginPath(); ctx.arc(n.x, n.y, 18, 0, 7); ctx.fillStyle = 'rgba(255,160,0,0.3)'; ctx.fill(); }
        if (p) {
            ctx.beginPath();
            if (p.type === 'king') { for(let i=0;i<6;i++) ctx.lineTo(n.x+20*Math.cos(i*Math.PI/3), n.y+20*Math.sin(i*Math.PI/3)); ctx.closePath(); }
            else ctx.arc(n.x, n.y, 16, 0, 7);
            ctx.fillStyle = '#fff'; ctx.fill();
            ctx.strokeStyle = p.team === 'blue' ? '#2563EB' : '#DC2626'; ctx.lineWidth = 3; ctx.stroke();
            ctx.fillStyle = ctx.strokeStyle; ctx.font = "bold 16px Arial"; ctx.textAlign = "center";
            let icon = p.type === 'king' ? 'K' : (p.type === 'triangle' ? '▲' : (p.type === 'square' ? '■' : 'X'));
            ctx.fillText(icon, n.x, n.y+6);
        }
    }
}

function updateStatus() { 
    const s = document.getElementById('status');
    s.innerText = gameState.turn.toUpperCase() + " TURN";
    s.style.color = gameState.turn === 'blue' ? '#2563EB' : '#DC2626';
}

function broadcastState() { if(conn && conn.open) conn.send(gameState); spectators.forEach(s => s.open && s.send(gameState)); }
function syncMyInfo() { if(conn && conn.open) conn.send({type:'INFO_SYNC', name:myTelegramName, iq:userScore, role:myRole}); }
function handleSurrender() { tg.showConfirm("Surrender?", ok => ok && endGame(myRole === 'blue' ? 'red' : 'blue', 'SURRENDER')); }
function handleDrawRequest() { conn && conn.send({type:'DRAW_OFFER'}); }
function toggleUI() { document.getElementById('ui-container').classList.toggle('hidden'); }
function inviteTelegramFriend() {
    const url = `https://t.me/Iq17game_bot/IQ17?startapp=${peer.id}`;
    tg.openTelegramLink(`https://t.me/share/url?url=${encodeURIComponent(url)}`);
}

window.onbeforeunload = () => { if(conn && conn.open && !gameState.gameOver) endGame(myRole === 'blue' ? 'red' : 'blue', 'DISCONNECT'); };

peer.on('open', id => {
    const p = tg.initDataUnsafe.start_param;
    if(p) { conn = peer.connect(p); myRole = 'red'; setupConnection(); } else { myRole = 'blue'; updateStatus(); }
    tg.CloudStorage.getItem('player_iq_final_v1', (err, v) => { if(v) userScore = parseInt(v); document.getElementById('blue-iq-val').innerText = userScore; });
});
peer.on('connection', c => { conn = c; setupConnection(); });
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.touches[0], r = canvas.getBoundingClientRect();
    const x = t.clientX - r.left, y = t.clientY - r.top;
    for(let id in nodes) if(Math.hypot(nodes[id].x-x, nodes[id].y-y) < 30) handleInteraction(id);
});
drawBoard();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IQ 17 - Top Left UI</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #fff; font-family: sans-serif; text-align: center; overflow: hidden; height: 100vh; }
        canvas { display: block; margin: 0 auto; touch-action: none; background: #ffffff; }
        
        /* Floating UI at the top-left */
        #ui-overlay { 
            position: fixed; top: 10px; left: 10px; 
            text-align: left; pointer-events: none; z-index: 10; 
        }
        #status { font-size: 14px; font-weight: bold; text-transform: uppercase; margin-bottom: 5px; pointer-events: auto; }
        
        .dropdown { position: relative; display: inline-block; pointer-events: auto; }
        #invite-label { 
            background: none; border: none; color: #0088cc; 
            font-weight: bold; font-size: 16px; cursor: pointer; padding: 5px 0; 
        }
        
        .dropdown-content { 
            display: none; position: absolute; top: 100%; left: 0; 
            background-color: white; min-width: 160px; box-shadow: 0px 4px 12px rgba(0,0,0,0.15); 
            z-index: 11; border-radius: 8px; overflow: hidden; margin-top: 5px; border: 1px solid #eee;
        }
        .dropdown-content button { 
            width: 100%; border: none; padding: 12px; background: white; color: #333; 
            cursor: pointer; font-size: 14px; border-bottom: 1px solid #f0f0f0; text-align: left;
        }
        .dropdown-content button:last-child { border-bottom: none; }
        .show { display: block; }
        
        #game-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; flex-direction: column; justify-content: center; align-items: center; color: white; }
    </style>
</head>
<body>

    <div id="game-overlay">
        <div style="background:white; padding:30px; border-radius:15px; color:#333;">
            <h2 id="win-message">BLUE WINS!</h2>
            <button style="padding:10px 20px; background:#00AD11; color:white; border:none; border-radius:5px;" onclick="triggerRestart()">Restart</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-overlay">
        <div id="status">BLUE'S TURN</div>
        <div class="dropdown">
            <button id="invite-label" onclick="toggleMenu(event)">Invite â–¾</button>
            <div class="dropdown-content" id="myDropdown">
                <button onclick="inviteTelegramFriend('player')">Challenge Friend</button>
                <button onclick="inviteTelegramFriend('spectator')">Invite Spectator</button>
            </div>
        </div>
    </div>

<script>
const tg = window.Telegram.WebApp;
tg.expand();

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const dropdownContent = document.getElementById('myDropdown');
const statusDiv = document.getElementById('status');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- Scaling Adjustments to keep Red King on screen ---
const scaleX = canvas.width / 400;
// We use canvas.height - 100 to ensure the bottom nodes (Red King) don't hit the very edge
const boardHeight = canvas.height - 120; 
const scaleY = boardHeight / 850; 
const yOffset = 80; // Pushes the top nodes down slightly to make room for Invite text

const nodes = {
    0: {x: 200*scaleX, y: 0*scaleY + yOffset}, 1: {x: 80*scaleX, y: 70*scaleY + yOffset}, 2: {x: 160*scaleX, y: 70*scaleY + yOffset}, 3: {x: 240*scaleX, y: 70*scaleY + yOffset}, 4: {x: 320*scaleX, y: 70*scaleY + yOffset}, 
    5: {x: 80*scaleX, y: 160*scaleY + yOffset}, 6: {x: 160*scaleX, y: 160*scaleY + yOffset}, 7: {x: 240*scaleX, y: 160*scaleY + yOffset}, 8: {x: 320*scaleX, y: 160*scaleY + yOffset}, 
    9: {x: 80*scaleX, y: 250*scaleY + yOffset}, 10: {x: 160*scaleX, y: 250*scaleY + yOffset}, 11: {x: 240*scaleX, y: 250*scaleY + yOffset}, 12: {x: 320*scaleX, y: 250*scaleY + yOffset}, 
    13: {x: 25*scaleX, y: 340*scaleY + yOffset}, 14: {x: 95*scaleX, y: 340*scaleY + yOffset}, 15: {x: 165*scaleX, y: 340*scaleY + yOffset}, 16: {x: 235*scaleX, y: 340*scaleY + yOffset}, 17: {x: 305*scaleX, y: 340*scaleY + yOffset}, 18: {x: 375*scaleX, y: 340*scaleY + yOffset}, 
    19: {x: 25*scaleX, y: 420*scaleY + yOffset}, 20: {x: 95*scaleX, y: 420*scaleY + yOffset}, 21: {x: 165*scaleX, y: 420*scaleY + yOffset}, 22: {x: 235*scaleX, y: 420*scaleY + yOffset}, 23: {x: 305*scaleX, y: 420*scaleY + yOffset}, 24: {x: 375*scaleX, y: 420*scaleY + yOffset}, 
    30: {x: 25*scaleX, y: 500*scaleY + yOffset}, 29: {x: 95*scaleX, y: 500*scaleY + yOffset}, 28: {x: 165*scaleX, y: 500*scaleY + yOffset}, 27: {x: 235*scaleX, y: 500*scaleY + yOffset}, 26: {x: 305*scaleX, y: 500*scaleY + yOffset}, 25: {x: 375*scaleX, y: 500*scaleY + yOffset}, 
    31: {x: 80*scaleX, y: 590*scaleY + yOffset}, 32: {x: 160*scaleX, y: 590*scaleY + yOffset}, 33: {x: 240*scaleX, y: 590*scaleY + yOffset}, 34: {x: 320*scaleX, y: 590*scaleY + yOffset}, 
    38: {x: 80*scaleX, y: 680*scaleY + yOffset}, 37: {x: 160*scaleX, y: 680*scaleY + yOffset}, 36: {x: 240*scaleX, y: 680*scaleY + yOffset}, 35: {x: 320*scaleX, y: 680*scaleY + yOffset}, 
    39: {x: 80*scaleX, y: 770*scaleY + yOffset}, 40: {x: 160*scaleX, y: 770*scaleY + yOffset}, 41: {x: 240*scaleX, y: 770*scaleY + yOffset}, 42: {x: 320*scaleX, y: 770*scaleY + yOffset}, 43: {x: 200*scaleX, y: 840*scaleY + yOffset}
};

const roads = [[0,2],[0,3],[1,2],[2,3],[3,4],[1,5],[2,6],[3,7],[4,8],[5,6],[6,7],[7,8],[5,9],[6,10],[7,11],[8,12],[9,10],[10,11],[11,12],[2,5],[3,6],[6,9],[4,7],[7,10],[8,11],[9,13],[9,14],[10,14],[10,15],[11,16],[11,17],[12,18],[12,17],[13,14],[14,15],[16,17],[17,18],[13,19],[14,20],[15,21],[16,22],[17,23],[18,24],[19,20],[20,21],[22,23],[23,24],[19,30],[20,29],[21,28],[22,27],[23,26],[24,25],[30,29],[29,28],[27,26],[26,25],[15,22],[21,27],[31,30],[31,29],[32,29],[32,28],[33,27],[33,26],[34,26],[34,25],[31,32],[32,33],[33,34],[31,38],[32,37],[33,36],[34,35],[38,37],[37,36],[36,35],[38,39],[37,40],[36,41],[35,42],[39,40],[40,41],[41,42],[40,43],[41,43],[38,32],[39,37],[37,33],[40,36],[36,34],[41,35],[18,23],[23,27],[16,23],[23,25],[13,20],[20,28],[15,20],[20,30]];

// UI Toggle logic
function toggleMenu(event) {
    event.stopPropagation();
    dropdownContent.classList.toggle("show");
}

window.onclick = function(event) {
    if (!event.target.matches('#invite-label')) {
        dropdownContent.classList.remove('show');
    }
}

// Logic & Drawing
function getValidMoves(startNode) {
    if (startNode === null) return [];
    const piece = gameState.pieces[startNode];
    let valid = [], visited = new Map();
    const isSpecial = (piece.type === 'triangle' || piece.type === 'king');
    const maxDist = isSpecial ? 3 : 1;
    let queue = [{id: startNode, dist: 0, lastNode: null}];
    visited.set(startNode, 0);

    while (queue.length > 0) {
        let current = queue.shift();
        if (current.dist >= maxDist) continue;
        let neighbors = roads.filter(r => r.includes(current.id)).map(r => r[0] === current.id ? r[1] : r[0]);
        neighbors.forEach(neighbor => {
            if (isSpecial && current.lastNode !== null) {
                const p1 = nodes[current.lastNode], p2 = nodes[current.id], p3 = nodes[neighbor];
                let diff = Math.abs(Math.atan2(p2.y - p1.y, p2.x - p1.x) - Math.atan2(p3.y - p2.y, p3.x - p2.x));
                if (diff > Math.PI) diff = 2 * Math.PI - diff;
                if (diff * (180 / Math.PI) > 25.61) return; // Your zigzag turn rule
            }
            if (!visited.has(neighbor)) {
                const target = gameState.pieces[neighbor];
                if (target) { if (target.team !== piece.team) valid.push(neighbor); }
                else { valid.push(neighbor); queue.push({id: neighbor, dist: current.dist + 1, lastNode: current.id}); }
                visited.set(neighbor, current.dist + 1);
            }
        });
    }
    return [...new Set(valid)];
}

function drawHex(x,y,size){ctx.beginPath();for(let i=0;i<6;i++){ctx.lineTo(x+size*Math.cos(i*Math.PI/3),y+size*Math.sin(i*Math.PI/3))}ctx.closePath()}
function drawBoard(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle='#444'; ctx.lineWidth=2;
    roads.forEach(p=>{
        ctx.beginPath(); ctx.moveTo(nodes[p[0]].x,nodes[p[0]].y); ctx.lineTo(nodes[p[1]].x,nodes[p[1]].y); ctx.stroke();
    });
    const possible = getValidMoves(gameState.selectedNode);
    for(let id in nodes){
        const n = nodes[id]; const p = gameState.pieces[id];
        if(p){
            if(p.type==='king') drawHex(n.x,n.y,20); else { ctx.beginPath(); ctx.arc(n.x,n.y,16,0,7); }
            ctx.fillStyle='#fff'; ctx.fill();
            ctx.strokeStyle=p.team=='blue'?'#2563EB':'#DC2626'; ctx.lineWidth=3; ctx.stroke();
            ctx.fillStyle=ctx.strokeStyle; ctx.font='bold 16px Arial'; ctx.textAlign='center';
            ctx.fillText(p.type=='king'?'ðŸ‘‘':p.type=='triangle'?'â–²':p.type=='square'?'â– ':'X', n.x, n.y+6);
        }
        if(possible.includes(parseInt(id))){
            ctx.beginPath(); ctx.arc(n.x,n.y,10,0,7); ctx.fillStyle='rgba(255,215,0,0.6)'; ctx.fill();
        }
    }
}

// Remaining initialization and touch handlers...
canvas.addEventListener('touchstart', e => {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left, y = touch.clientY - rect.top;
    for(let id in nodes){
        if(Math.sqrt((x-nodes[id].x)**2 + (y-nodes[id].y)**2) < 30){
            handleInteraction(parseInt(id)); break;
        }
    }
});

let gameState = initialGameState();
function handleInteraction(id) {
    const target = gameState.pieces[id];
    if (target && target.team === gameState.turn) gameState.selectedNode = id;
    else if (gameState.selectedNode !== null && getValidMoves(gameState.selectedNode).includes(id)) {
        gameState.pieces[id] = gameState.pieces[gameState.selectedNode];
        delete gameState.pieces[gameState.selectedNode];
        gameState.turn = gameState.turn === 'blue' ? 'red' : 'blue';
        gameState.selectedNode = null;
        statusDiv.innerText = gameState.turn.toUpperCase() + "'S TURN";
        statusDiv.style.color = gameState.turn === 'blue' ? '#2563EB' : '#DC2626';
    }
    drawBoard();
}

drawBoard();
</script>
</body>
</html>

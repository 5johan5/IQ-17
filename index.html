<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IQ 17 - Pro Edition</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #fff; font-family: sans-serif; text-align: center; overflow: hidden; }
        canvas { border-bottom: 2px solid #ccc; display: block; margin: 0 auto; touch-action: none; background: #ffffff; }
        #ui { padding: 10px; background: #fff; height: 140px; }
        .btn { padding: 10px 20px; background: #0070FF; color: white; border: none; border-radius: 8px; cursor: pointer; margin: 5px; font-weight: bold; }
        #peer-id-display { font-size: 11px; color: #888; margin-top: 8px; }
        #status { font-size: 18px; font-weight: bold; color: #333; margin-bottom: 5px; }
        #game-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; flex-direction: column; justify-content: center; align-items: center; color: white; }
        .popup-box { background: white; padding: 30px; border-radius: 15px; color: #333; width: 80%; max-width: 300px; }
        .restart-btn { background: #00AD11; margin-top: 15px; }
        .close-btn { background: #888; }
    </style>
</head>
<body>

    <div id="game-overlay">
        <div class="popup-box">
            <h2 id="win-message">BLUE WINS!</h2>
            <button class="btn restart-btn" onclick="requestRestart()">Restart Game</button>
            <button class="btn close-btn" onclick="closePopup()">Close</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div id="status">Ready to Play</div>
        <div>
            <button class="btn" onclick="copyMyID()">Copy ID</button>
            <button class="btn" onclick="connectToPeer()">Join Friend</button>
        </div>
        <div id="peer-id-display">My ID: Loading...</div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const statusDiv = document.getElementById('status');
const idDisplay = document.getElementById('peer-id-display');
const overlay = document.getElementById('game-overlay');
const winMsg = document.getElementById('win-message');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 160;

// =========================================================
// --- CRITICAL FIX: FORCED RELAY CONFIG ---
// =========================================================
const peerConfig = {
    debug: 3, // Shows us exactly what's happening in the console
    config: {
        'iceServers': [
            { 'urls': 'stun:stun.l.google.com:19302' },
            {
                'urls': 'turn:global.relay.metered.ca:443', // Port 443 is harder to block
                'username': '12086455af0334c526b9d3da', 
                'credential': 'ZxLMG6ZJX9R7oyQE'
            }
        ],
        'iceTransportPolicy': 'relay', // FORCES the connection through Metered.ca
        'iceCandidatePoolSize': 10
    }
};

let peer = new Peer(peerConfig); 
// =========================================================

let conn = null;
let myRole = null; 

const initialGameState = () => ({
    turn: 'blue', selectedNode: null, lastMove: null, gameOver: false,
    pieces: {
        0:{team:'blue',type:'king'}, 3:{team:'blue',type:'triangle'}, 4:{team:'blue',type:'triangle'},
        5:{team:'blue',type:'square'}, 6:{team:'blue',type:'square'}, 7:{team:'blue',type:'square'}, 8:{team:'blue',type:'square'},
        9:{team:'blue',type:'x'}, 10:{team:'blue',type:'x'}, 11:{team:'blue',type:'x'}, 12:{team:'blue',type:'x'},
        43:{team:'red',type:'king'}, 39:{team:'red',type:'triangle'}, 40:{team:'red',type:'triangle'},
        35:{team:'red',type:'square'}, 36:{team:'red',type:'square'}, 37:{team:'red',type:'square'}, 38:{team:'red',type:'square'},
        31:{team:'red',type:'x'}, 32:{team:'red',type:'x'}, 33:{team:'red',type:'x'}, 34:{team:'red',type:'x'}
    }
});

let gameState = initialGameState();

peer.on('open', (id) => { idDisplay.innerText = "My ID: " + id; });
peer.on('connection', (c) => { 
    conn = c; 
    myRole = 'blue'; 
    setupConnection(); 
});

function connectToPeer() {
    let peerId = prompt("Enter Friend's ID:");
    if (peerId) { 
        statusDiv.innerText = "Tunneling... (Wait 5s)";
        conn = peer.connect(peerId, { reliable: true }); 
        myRole = 'red'; 
        setupConnection(); 
    }
}

function setupConnection() {
    conn.on('open', () => {
        statusDiv.innerText = "CONNECTED!";
        statusDiv.style.color = "#00AD11";
        if (myRole === 'blue') sendMove(); else conn.send("SYNC");
    });
    conn.on('data', (data) => { 
        if (data === "SYNC") { sendMove(); return; }
        if (data === "RESTART") { resetLocalGame(); return; }
        gameState = data; 
        if (gameState.gameOver) showWinPopup(gameState.winner);
        drawBoard(); updateStatus(); 
    });
    conn.on('error', (err) => {
        statusDiv.innerText = "Error: " + err.type;
        console.error(err);
    });
}

function sendMove() { if (conn && conn.open) conn.send(gameState); }
function requestRestart() { resetLocalGame(); if (conn && conn.open) conn.send("RESTART"); }
function resetLocalGame() { gameState = initialGameState(); overlay.style.display = 'none'; drawBoard(); updateStatus(); }
function closePopup() { overlay.style.display = 'none'; }
function showWinPopup(winner) { winMsg.innerText = winner.toUpperCase() + " WINS!"; winMsg.style.color = winner === 'blue' ? '#2563EB' : '#DC2626'; overlay.style.display = 'flex'; }

function checkWinConditions(targetId, movedPiece) {
    const targetPiece = gameState.pieces[targetId];
    if (targetPiece && targetPiece.type === 'king') return true;
    if (movedPiece.type === 'king') {
        if (movedPiece.team === 'blue' && targetId === 43) return true;
        if (movedPiece.team === 'red' && targetId === 0) return true;
    }
    return false;
}

function handleInteraction(id) {
    if (gameState.gameOver) return;
    const target = gameState.pieces[id];
    if (target && target.team === gameState.turn) {
        gameState.selectedNode = id;
    } else if (gameState.selectedNode !== null) {
        if (getValidMoves(gameState.selectedNode).includes(id)) {
            const movingPiece = gameState.pieces[gameState.selectedNode];
            if (checkWinConditions(id, movingPiece)) {
                gameState.gameOver = true;
                gameState.winner = gameState.turn;
                showWinPopup(gameState.turn);
            }
            gameState.lastMove = {from: gameState.selectedNode, to: id};
            gameState.pieces[id] = movingPiece; 
            delete gameState.pieces[gameState.selectedNode];
            gameState.turn = gameState.turn === 'blue' ? 'red' : 'blue'; 
            gameState.selectedNode = null; 
            sendMove();
        } else {
            gameState.selectedNode = null;
        }
    }
    drawBoard();
    updateStatus();
}

// --- BOARD SETUP (Nodes and Roads) ---
const scaleX = canvas.width / 400;
const scaleY = canvas.height / 700;
const nodes = {0: {x: 200*scaleX, y: 50*scaleY}, 1: {x: 80*scaleX, y: 110*scaleY}, 2: {x: 160*scaleX, y: 110*scaleY}, 3: {x: 240*scaleX, y: 110*scaleY}, 4: {x: 320*scaleX, y: 110*scaleY}, 5: {x: 80*scaleX, y: 180*scaleY}, 6: {x: 160*scaleX, y: 180*scaleY}, 7: {x: 240*scaleX, y: 180*scaleY}, 8: {x: 320*scaleX, y: 180*scaleY}, 9: {x: 80*scaleX, y: 250*scaleY}, 10: {x: 160*scaleX, y: 250*scaleY}, 11: {x: 240*scaleX, y: 250*scaleY}, 12: {x: 320*scaleX, y: 250*scaleY}, 13: {x: 50*scaleX, y: 320*scaleY}, 14: {x: 110*scaleX, y: 320*scaleY}, 15: {x: 170*scaleX, y: 320*scaleY}, 16: {x: 230*scaleX, y: 320*scaleY}, 17: {x: 290*scaleX, y: 320*scaleY}, 18: {x: 350*scaleX, y: 320*scaleY}, 19: {x: 50*scaleX, y: 370*scaleY}, 20: {x: 110*scaleX, y: 370*scaleY}, 21: {x: 170*scaleX, y: 370*scaleY}, 22: {x: 230*scaleX, y: 370*scaleY}, 23: {x: 290*scaleX, y: 370*scaleY}, 24: {x: 350*scaleX, y: 370*scaleY}, 30: {x: 50*scaleX, y: 420*scaleY}, 29: {x: 110*scaleX, y: 420*scaleY}, 28: {x: 170*scaleX, y: 420*scaleY}, 27: {x: 230*scaleX, y: 420*scaleY}, 26: {x: 290*scaleX, y: 420*scaleY}, 25: {x: 350*scaleX, y: 420*scaleY}, 31: {x: 80*scaleX, y: 490*scaleY}, 32: {x: 160*scaleX, y: 490*scaleY}, 33: {x: 240*scaleX, y: 490*scaleY}, 34: {x: 320*scaleX, y: 490*scaleY}, 38: {x: 80*scaleX, y: 560*scaleY}, 37: {x: 160*scaleX, y: 560*scaleY}, 36: {x: 240*scaleX, y: 560*scaleY}, 35: {x: 320*scaleX, y: 560*scaleY}, 39: {x: 80*scaleX, y: 630*scaleY}, 40: {x: 160*scaleX, y: 630*scaleY}, 41: {x: 240*scaleX, y: 630*scaleY}, 42: {x: 320*scaleX, y: 630*scaleY}, 43: {x: 200*scaleX, y: 680*scaleY}};
const roads = [[0,2],[0,3],[1,2],[2,3],[3,4],[1,5],[2,6],[3,7],[4,8],[5,6],[6,7],[7,8],[5,9],[6,10],[7,11],[8,12],[9,10],[10,11],[11,12],[2,5],[3,6],[6,9],[4,7],[7,10],[8,11],[9,13],[9,14],[10,14],[10,15],[11,16],[11,17],[12,18],[12,17],[13,14],[14,15],[16,17],[17,18],[13,19],[14,20],[15,21],[16,22],[17,23],[18,24],[19,20],[20,21],[22,23],[23,24],[19,30],[20,29],[21,28],[22,27],[23,26],[24,25],[30,29],[29,28],[27,26],[26,25],[15,22],[21,27],[31,30],[31,29],[32,29],[32,28],[33,27],[33,26],[34,26],[34,25],[31,32],[32,33],[33,34],[31,38],[32,37],[33,36],[34,35],[38,37],[37,36],[36,35],[38,39],[37,40],[36,41],[35,42],[39,40],[40,41],[41,42],[40,43],[41,43],[38,32],[39,37],[37,33],[40,36],[36,34],[41,35],[18,23],[23,27],[16,23],[23,25],[13,20],[20,28],[15,20],[20,30]];

function getValidMoves(startNode){if(startNode===null)return[];const piece=gameState.pieces[startNode];let valid=[];let visited=new Map();let queue=[{id:startNode,dist:0}];visited.set(startNode,0);const maxDist=(piece.type==='triangle'||piece.type==='king')?4:1;while(queue.length>0){let current=queue.shift();if(current.dist>=maxDist)continue;let neighbors=roads.filter(r=>r.includes(current.id)).map(r=>r[0]===current.id?r[1]:r[0]);neighbors.forEach(neighbor=>{if(!visited.has(neighbor)){const targetPiece=gameState.pieces[neighbor];if(piece.type==='x'){const isBackward=piece.team==='blue'?nodes[neighbor].y<nodes[startNode].y:nodes[neighbor].y>nodes[startNode].y;const isBridge=(startNode==15&&neighbor==22)||(startNode==22&&neighbor==15)||(startNode==21&&neighbor==27)||(startNode==27&&neighbor==21);if(isBackward&&(!isBridge||!targetPiece||targetPiece.team===piece.team))return;if(targetPiece&&targetPiece.type==='square')return}if(targetPiece){if(targetPiece.team!==piece.team)valid.push(neighbor);visited.set(neighbor,current.dist+1)}else{valid.push(neighbor);visited.set(neighbor,current.dist+1);queue.push({id:neighbor,dist:current.dist+1})}}})}return[...new Set(valid)]}
function drawHex(x,y,size){ctx.beginPath();for(let i=0;i<6;i++){ctx.lineTo(x+size*Math.cos(i*Math.PI/3),y+size*Math.sin(i*Math.PI/3))}ctx.closePath()}
function drawBoard(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.strokeStyle='#444';ctx.lineWidth=2.5;roads.forEach(p=>{ctx.beginPath();ctx.moveTo(nodes[p[0]].x,nodes[p[0]].y);ctx.lineTo(nodes[p[1]].x,nodes[p[1]].y);ctx.stroke()});const possible=getValidMoves(gameState.selectedNode);for(let id in nodes){const n=nodes[id];const p=gameState.pieces[id];const numId=parseInt(id);if(gameState.lastMove&&(gameState.lastMove.from===numId||gameState.lastMove.to===numId)){ctx.beginPath();ctx.arc(n.x,n.y,22,0,7);ctx.fillStyle='rgba(0,0,0,0.1)';ctx.fill()}if(gameState.selectedNode===numId){ctx.beginPath();ctx.arc(n.x,n.y,22,0,7);ctx.fillStyle='rgba(0,112,255,0.2)';ctx.fill()}if(possible.includes(numId)){ctx.beginPath();ctx.arc(n.x,n.y,18,0,7);ctx.fillStyle='rgba(255,215,0,0.5)';ctx.fill()}if(p&&p.type==='king'){drawHex(n.x,n.y,20);ctx.fillStyle='#fff';ctx.fill();ctx.strokeStyle=p.team=='blue'?'#2563EB':'#DC2626';ctx.lineWidth=3;ctx.stroke()}else{ctx.beginPath();ctx.arc(n.x,n.y,16,0,7);ctx.fillStyle='#fff';ctx.fill();ctx.strokeStyle=p?(p.team=='blue'?'#2563EB':'#DC2626'):'#ccc';ctx.lineWidth=2;ctx.stroke()}if(p){ctx.fillStyle=p.team=='blue'?'#2563EB':'#DC2626';ctx.font='bold 18px Arial';ctx.textAlign='center';let icon=p.type=='king'?'ðŸ‘‘':p.type=='triangle'?'â–²':p.type=='square'?'â– ':'X';ctx.fillText(icon,n.x,n.y+(p.type=='king'?7:6))}}}
function updateStatus(){if(statusDiv.innerText==="CONNECTED!")return;statusDiv.innerText=gameState.turn.toUpperCase()+"'s Turn";statusDiv.style.color=gameState.turn==='blue'?'#2563EB':'#DC2626'}
canvas.addEventListener('touchstart',e=>{e.preventDefault();if(myRole&&gameState.turn!==myRole)return;const touch=e.touches[0];const rect=canvas.getBoundingClientRect();const x=touch.clientX-rect.left;const y=touch.clientY-rect.top;for(let id in nodes){if(Math.sqrt((x-nodes[id].x)**2+(y-nodes[id].y)**2)<30){handleInteraction(parseInt(id));break}}});
function copyMyID(){const id=idDisplay.innerText.replace("My ID: ","");navigator.clipboard.writeText(id).then(()=>alert("ID Copied!"));}
drawBoard();
</script>
</body>
</html>

